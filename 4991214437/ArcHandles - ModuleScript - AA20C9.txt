-- Legit-GDumper by legitimate0x1!

-- Path --> Players.legitimate0x2.Backpack.Building Tools.Libraries.ArcHandles
-- Decompiled with Konstant V2.1, a fast Luau decompiler made in Luau by plusgiant5 (https://discord.gg/wyButjTMhM)
-- Decompiled on 2024-11-03 06:34:23
-- Luau version 6, Types version 3
-- Time taken: 0.011191 seconds

local Workspace_upvr = game:GetService("Workspace")
local module_upvr = require(script.Parent:WaitForChild("Maid"))
local module_upvr_3 = require(script.Parent:WaitForChild("SupportLibrary"))
local module_upvr_2 = {}
module_upvr_2.__index = module_upvr_2
module_upvr_2.SideToAxis = {
	Top = 'Z';
	Bottom = 'Z';
	Left = 'Y';
	Right = 'Y';
	Front = 'X';
	Back = 'X';
}
module_upvr_2.AxisToSide = {
	X = "Front";
	Y = "Right";
	Z = "Top";
}
module_upvr_2.AxisColors = {
	X = Color3.new(1, 0, 0);
	Y = Color3.new(0, 1, 0);
	Z = Color3.new(0, 0, 1);
}
module_upvr_2.CircleSlices = 60
local UserInputService_upvr = game:GetService("UserInputService")
local GuiService_upvr = game:GetService("GuiService")
function module_upvr_2.new(arg1) -- Line 41
	--[[ Upvalues[6]:
		[1]: module_upvr_2 (readonly)
		[2]: module_upvr (readonly)
		[3]: UserInputService_upvr (readonly)
		[4]: Workspace_upvr (readonly)
		[5]: GuiService_upvr (readonly)
		[6]: module_upvr_3 (readonly)
	]]
	local setmetatable_result1 = setmetatable({}, module_upvr_2)
	setmetatable_result1.Maid = module_upvr.new()
	local ScreenGui = Instance.new("ScreenGui")
	setmetatable_result1.Gui = ScreenGui
	ScreenGui.Name = "BTArcHandles"
	ScreenGui.IgnoreGuiInset = true
	setmetatable_result1.Maid.Gui = ScreenGui
	setmetatable_result1.IsMouseAvailable = UserInputService_upvr.MouseEnabled
	setmetatable_result1:CreateCircles()
	setmetatable_result1:CreateHandles(arg1)
	setmetatable_result1.Camera = Workspace_upvr.CurrentCamera
	setmetatable_result1.GuiInset = GuiService_upvr:GetGuiInset()
	local ObstacleBlacklist = arg1.ObstacleBlacklist
	if not ObstacleBlacklist then
		ObstacleBlacklist = {}
	end
	setmetatable_result1.ObstacleBlacklistIndex = module_upvr_3.FlipTable(ObstacleBlacklist)
	setmetatable_result1.ObstacleBlacklist = module_upvr_3.Keys(setmetatable_result1.ObstacleBlacklistIndex)
	setmetatable_result1:SetAdornee(arg1.Adornee)
	setmetatable_result1.Gui.Parent = arg1.Parent
	return setmetatable_result1
end
function module_upvr_2.CreateCircles(arg1) -- Line 75
	local Folder = Instance.new("Folder")
	Folder.Name = "AxisCircles"
	Folder.Parent = arg1.Gui
	local tbl_2 = {}
	arg1.AxisCircles = tbl_2
	for _, v in ipairs(Enum.Axis:GetEnumItems()) do
		local var24 = arg1.AxisColors[v.Name]
		local Folder_2 = Instance.new("Folder", Folder)
		Folder_2.Name = v.Name
		local tbl = {}
		tbl_2[v.Name] = tbl
		for i_2 = 1, arg1.CircleSlices do
			local CylinderHandleAdornment = Instance.new("CylinderHandleAdornment")
			CylinderHandleAdornment.Transparency = 0.4
			CylinderHandleAdornment.Color3 = var24
			CylinderHandleAdornment.Radius = 0
			CylinderHandleAdornment.Height = 0
			CylinderHandleAdornment.Parent = Folder_2
			tbl[i_2] = CylinderHandleAdornment
		end
	end
end
function module_upvr_2.CreateHandles(arg1, arg2) -- Line 111
	--[[ Upvalues[2]:
		[1]: module_upvr (readonly)
		[2]: module_upvr_3 (readonly)
	]]
	local Folder_3 = Instance.new("Folder")
	Folder_3.Name = "Handles"
	Folder_3.Parent = arg1.Gui
	arg1.Handles = {}
	arg1.HandleStates = {}
	for _, v_2 in ipairs(Enum.NormalId:GetEnumItems()) do
		local var36_upvr = arg1.SideToAxis[v_2.Name]
		local ImageButton_upvr = Instance.new("ImageButton")
		ImageButton_upvr.Name = v_2.Name
		ImageButton_upvr.Image = "rbxassetid://2347145012"
		ImageButton_upvr.ImageColor3 = arg1.AxisColors[var36_upvr]
		ImageButton_upvr.ImageTransparency = 0.33
		ImageButton_upvr.AnchorPoint = Vector2.new(0.5, 0.5)
		ImageButton_upvr.BackgroundTransparency = 1
		ImageButton_upvr.BorderSizePixel = 0
		ImageButton_upvr.ZIndex = 1
		local clone = ImageButton_upvr:Clone()
		clone.Active = false
		clone.Size = UDim2.new(0, 4, 0, 4)
		clone.Position = UDim2.new(0.5, 0, 0.5, 0)
		clone.Parent = ImageButton_upvr
		clone.ZIndex = 0
		local any_new_result1_2_upvr = module_upvr.new()
		arg1.Maid[v_2.Name] = any_new_result1_2_upvr
		any_new_result1_2_upvr.HoverStart = ImageButton_upvr.MouseEnter:Connect(function() -- Line 151
			--[[ Upvalues[3]:
				[1]: ImageButton_upvr (readonly)
				[2]: arg1 (readonly)
				[3]: var36_upvr (readonly)
			]]
			ImageButton_upvr.ImageTransparency = 0
			arg1:SetCircleTransparency(var36_upvr, 0)
		end)
		any_new_result1_2_upvr.HoverEnd = ImageButton_upvr.MouseLeave:Connect(function() -- Line 155
			--[[ Upvalues[3]:
				[1]: ImageButton_upvr (readonly)
				[2]: arg1 (readonly)
				[3]: var36_upvr (readonly)
			]]
			ImageButton_upvr.ImageTransparency = 0.33
			arg1:SetCircleTransparency(var36_upvr, 0.4)
		end)
		any_new_result1_2_upvr.DragStart = ImageButton_upvr.MouseButton1Down:Connect(function(arg1_2, arg2_2) -- Line 161
			--[[ Upvalues[7]:
				[1]: arg1 (readonly)
				[2]: ImageButton_upvr (readonly)
				[3]: arg2 (readonly)
				[4]: var36_upvr (readonly)
				[5]: module_upvr (copied, readonly)
				[6]: any_new_result1_2_upvr (readonly)
				[7]: module_upvr_3 (copied, readonly)
			]]
			local PlaneNormal_upvr = arg1.HandleStates[ImageButton_upvr].PlaneNormal
			local HandleCFrame_upvr = arg1.HandleStates[ImageButton_upvr].HandleCFrame
			local AdorneeCFrame_upvr = arg1.HandleStates[ImageButton_upvr].AdorneeCFrame
			local any_ViewportPointToRay_result1 = arg1.Camera:ViewportPointToRay(arg1_2, arg2_2)
			if arg2.OnDragStart then
				arg2.OnDragStart()
			end
			local any_PointToObjectSpace_result1_2_upvr = AdorneeCFrame_upvr:PointToObjectSpace(HandleCFrame_upvr.p - any_ViewportPointToRay_result1.Origin:Dot(PlaneNormal_upvr) / any_ViewportPointToRay_result1.Direction:Dot(PlaneNormal_upvr) * any_ViewportPointToRay_result1.Direction + any_ViewportPointToRay_result1.Origin)
			local function ProcessDragChange_upvr(arg1_3) -- Line 177, Named "ProcessDragChange"
				--[[ Upvalues[7]:
					[1]: arg1 (copied, readonly)
					[2]: HandleCFrame_upvr (readonly)
					[3]: PlaneNormal_upvr (readonly)
					[4]: AdorneeCFrame_upvr (readonly)
					[5]: var36_upvr (copied, readonly)
					[6]: any_PointToObjectSpace_result1_2_upvr (readonly)
					[7]: arg2 (copied, readonly)
				]]
				-- KONSTANTERROR: [0] 1. Error Block 18 start (CF ANALYSIS FAILED)
				local any_ScreenPointToRay_result1 = arg1.Camera:ScreenPointToRay(arg1_3.X, arg1_3.Y)
				local any_PointToObjectSpace_result1 = AdorneeCFrame_upvr:PointToObjectSpace(HandleCFrame_upvr.p - any_ScreenPointToRay_result1.Origin:Dot(PlaneNormal_upvr) / any_ScreenPointToRay_result1.Direction:Dot(PlaneNormal_upvr) * any_ScreenPointToRay_result1.Direction + any_ScreenPointToRay_result1.Origin)
				local var50
				if var36_upvr == 'X' then
					var50 = math.atan2(any_PointToObjectSpace_result1.Y, -any_PointToObjectSpace_result1.Z) - math.atan2(any_PointToObjectSpace_result1_2_upvr.Y, -any_PointToObjectSpace_result1_2_upvr.Z)
					-- KONSTANTWARNING: GOTO [116] #78
				end
				-- KONSTANTERROR: [0] 1. Error Block 18 end (CF ANALYSIS FAILED)
				-- KONSTANTERROR: [66] 46. Error Block 19 start (CF ANALYSIS FAILED)
				if var36_upvr == 'Y' then
					var50 = math.atan2(any_PointToObjectSpace_result1.X, any_PointToObjectSpace_result1.Z) - math.atan2(any_PointToObjectSpace_result1_2_upvr.X, any_PointToObjectSpace_result1_2_upvr.Z)
				elseif var36_upvr == 'Z' then
					var50 = math.atan2(-any_PointToObjectSpace_result1.X, any_PointToObjectSpace_result1.Y) - math.atan2(any_PointToObjectSpace_result1_2_upvr.X, any_PointToObjectSpace_result1_2_upvr.Y)
				end
				if arg2.OnDrag then
					arg2.OnDrag(var36_upvr, var50)
				end
				-- KONSTANTERROR: [66] 46. Error Block 19 end (CF ANALYSIS FAILED)
			end
			local any_new_result1 = module_upvr.new()
			any_new_result1_2_upvr.Dragging = any_new_result1
			any_new_result1.Drag = module_upvr_3.AddUserInputListener("Changed", {"MouseMovement", "Touch"}, true, function(arg1_4) -- Line 210
				--[[ Upvalues[1]:
					[1]: ProcessDragChange_upvr (readonly)
				]]
				ProcessDragChange_upvr(arg1_4.Position)
			end)
			any_new_result1.InHandleDrag = ImageButton_upvr.MouseMoved:Connect(function(arg1_5, arg2_3) -- Line 215
				--[[ Upvalues[2]:
					[1]: arg1 (copied, readonly)
					[2]: ProcessDragChange_upvr (readonly)
				]]
				ProcessDragChange_upvr(Vector2.new(arg1_5, arg2_3) - arg1.GuiInset)
			end)
			any_new_result1.DragEnd = module_upvr_3.AddUserInputListener("Ended", {"MouseButton1", "Touch"}, true, function(arg1_6) -- Line 221
				--[[ Upvalues[1]:
					[1]: any_new_result1_2_upvr (copied, readonly)
				]]
				any_new_result1_2_upvr.Dragging = nil
			end)
			function any_new_result1.Callback() -- Line 226
				--[[ Upvalues[1]:
					[1]: arg2 (copied, readonly)
				]]
				coroutine.wrap(arg2.OnDragEnd)()
			end
		end)
		any_new_result1_2_upvr.InHandleDragEnd = ImageButton_upvr.MouseButton1Up:Connect(function() -- Line 233
			--[[ Upvalues[1]:
				[1]: any_new_result1_2_upvr (readonly)
			]]
			any_new_result1_2_upvr.Dragging = nil
		end)
		ImageButton_upvr.Parent = Folder_3
		arg1.Handles[v_2.Name] = ImageButton_upvr
	end
end
function module_upvr_2.Hide(arg1) -- Line 245
	if not arg1.Running then
		return arg1
	end
	arg1:Pause()
	arg1.Gui.Enabled = false
end
function module_upvr_2.Pause(arg1) -- Line 260
	arg1.Running = false
end
local function _(arg1) -- Line 264, Named "IsFirstPerson"
	local var59
	if (arg1.CFrame.p - arg1.Focus.p).magnitude > 0.6 then
		var59 = false
	else
		var59 = true
	end
	return var59
end
local RunService_upvr = game:GetService("RunService")
local Players_upvr = game:GetService("Players")
function module_upvr_2.Resume(arg1) -- Line 268
	--[[ Upvalues[3]:
		[1]: RunService_upvr (readonly)
		[2]: Players_upvr (readonly)
		[3]: module_upvr_3 (readonly)
	]]
	if arg1.Running then
		return arg1
	end
	arg1.Running = true
	for i_4_upvr, v_3_upvr in pairs(arg1.Handles) do
		coroutine.wrap(function() -- Line 280
			--[[ Upvalues[4]:
				[1]: arg1 (readonly)
				[2]: i_4_upvr (readonly)
				[3]: v_3_upvr (readonly)
				[4]: RunService_upvr (copied, readonly)
			]]
			while arg1.Running do
				arg1:UpdateHandle(i_4_upvr, v_3_upvr)
				RunService_upvr.RenderStepped:Wait()
			end
		end)()
	end
	for i_5_upvr, v_4_upvr in pairs(arg1.AxisCircles) do
		coroutine.wrap(function() -- Line 290
			--[[ Upvalues[4]:
				[1]: arg1 (readonly)
				[2]: i_5_upvr (readonly)
				[3]: v_4_upvr (readonly)
				[4]: RunService_upvr (copied, readonly)
			]]
			while arg1.Running do
				arg1:UpdateCircle(i_5_upvr, v_4_upvr)
				RunService_upvr.RenderStepped:Wait()
			end
		end)()
	end
	if Players_upvr.LocalPlayer then
		coroutine.wrap(function() -- Line 300
			--[[ Upvalues[3]:
				[1]: arg1 (readonly)
				[2]: Players_upvr (copied, readonly)
				[3]: module_upvr_3 (copied, readonly)
			]]
			while true do
				local var75
				var75 = arg1.Running
				if not var75 then break end
				local Camera = arg1.Camera
				if (Camera.CFrame.p - Camera.Focus.p).magnitude > 0.6 then
					var75 = false
				else
					var75 = true
				end
				local Character = Players_upvr.LocalPlayer.Character
				if Character then
					local var78 = arg1
					if var75 then
						var78 = true
					else
						var78 = nil
					end
					var78.ObstacleBlacklistIndex[Character] = var78
					arg1.ObstacleBlacklist = module_upvr_3.Keys(arg1.ObstacleBlacklistIndex)
				end
				wait(0.2)
			end
		end)()
	end
	arg1.Gui.Enabled = true
end
function module_upvr_2.SetAdornee(arg1, arg2) -- Line 318
	arg1.Adornee = arg2
	local var87
	local function INLINED() -- Internal function, doesn't exist in bytecode
		var87 = arg2:IsA("Model")
		return var87
	end
	if not arg2 or not INLINED() then
		var87 = nil
	end
	arg1.IsAdorneeModel = var87
	var87 = pairs(arg1.AxisCircles)
	local pairs_result1_2, pairs_result2, pairs_result3 = pairs(arg1.AxisCircles)
	for _, v_5 in pairs_result1_2, pairs_result2, pairs_result3 do
		for _, v_6 in ipairs(v_5) do
			v_6.Adornee = arg2
		end
	end
	if arg2 then
		pairs_result1_2 = arg1:Resume
		pairs_result1_2()
		return arg1
	end
	pairs_result1_2 = arg1:Hide
	pairs_result1_2()
	return arg1
end
function module_upvr_2.SetCircleTransparency(arg1, arg2, arg3) -- Line 344
	for _, v_7 in ipairs(arg1.AxisCircles[arg2]) do
		v_7.Transparency = arg3
	end
end
local function _(arg1, arg2) -- Line 350, Named "WorldToViewportPoint"
	local any_WorldToViewportPoint_result1_3, any_WorldToViewportPoint_result2 = arg1:WorldToViewportPoint(arg2)
	local Z_5 = any_WorldToViewportPoint_result1_3.Z
	any_WorldToViewportPoint_result1_3 = Vector2.new(any_WorldToViewportPoint_result1_3.X, any_WorldToViewportPoint_result1_3.Y)
	local var102 = any_WorldToViewportPoint_result1_3
	if Z_5 < 0 then
		var102 = arg1.ViewportSize - var102
	end
	return var102, Z_5, any_WorldToViewportPoint_result2
end
function module_upvr_2.BlacklistObstacle(arg1, arg2) -- Line 367
	--[[ Upvalues[1]:
		[1]: module_upvr_3 (readonly)
	]]
	if arg2 then
		arg1.ObstacleBlacklistIndex[arg2] = true
		arg1.ObstacleBlacklist = module_upvr_3.Keys(arg1.ObstacleBlacklistIndex)
	end
end
function module_upvr_2.UpdateHandle(arg1, arg2, arg3) -- Line 374
	--[[ Upvalues[1]:
		[1]: Workspace_upvr (readonly)
	]]
	-- KONSTANTWARNING: Variable analysis failed. Output will have some incorrect variable assignments
	local Camera_2 = arg1.Camera
	local var104
	if not var104 then
		var104 = false
		arg3.Visible = var104
	else
		local function INLINED_2() -- Internal function, doesn't exist in bytecode
			var104 = arg1.Adornee:GetModelCFrame()
			return var104
		end
		if not arg1.IsAdorneeModel or not INLINED_2() then
			var104 = arg1.Adornee.CFrame
		end
		if not arg1.IsAdorneeModel or not arg1.Adornee:GetModelSize() then
		end
		local any_WorldToViewportPoint_result1_4, _ = Camera_2:WorldToViewportPoint(var104.p)
		local Z = any_WorldToViewportPoint_result1_4.Z
		any_WorldToViewportPoint_result1_4 = Vector2.new(any_WorldToViewportPoint_result1_4.X, any_WorldToViewportPoint_result1_4.Y)
		local var108 = any_WorldToViewportPoint_result1_4
		if Z < 0 then
			var108 = Camera_2.ViewportSize - var108
		end
		local var109 = 1
		if arg1.IsMouseAvailable then
			var109 = 1
		else
			var109 = 1.6
		end
		local var110 = var104 * CFrame.new((arg1.Adornee.Size.magnitude / 2 + (2) * (math.max(var109, 2 * math.tan(math.rad(Camera_2.FieldOfView) / 2) * Z / Camera_2.ViewportSize.X * 14) * var109)) * Vector3.FromNormalId(arg2))
		local any_WorldToViewportPoint_result1_5, any_WorldToViewportPoint_result2_2 = Camera_2:WorldToViewportPoint(var110.p)
		local Z_4 = any_WorldToViewportPoint_result1_5.Z
		if Z_4 < 0 then
		end
		local var114 = Camera_2.ViewportSize - Vector2.new(any_WorldToViewportPoint_result1_5.X, any_WorldToViewportPoint_result1_5.Y)
		local var115 = Z_4
		arg3.Visible = any_WorldToViewportPoint_result2_2
		local var116 = 12
		if arg1.IsMouseAvailable then
			var116 = 1
		else
			var116 = 1.6
		end
		local var117 = math.max(var116, (0.5) * ((Camera_2.ViewportSize.X) / (2 * math.tan(math.rad(Camera_2.FieldOfView) / 2) * var115))) * var116
		arg3.Size = UDim2.new(0, var117, 0, var117)
		arg3.Position = UDim2.new(0, var114.X, 0, var114.Y)
		local var118 = arg1.HandleStates[arg3]
		if not var118 then
			var118 = {}
		end
		arg1.HandleStates[arg3] = var118
		var118.HandleCFrame = var110
		var118.PlaneNormal = (var104 * Vector3.FromAxis(arg1.SideToAxis[arg2]) - var104.p).unit
		var118.AdorneeCFrame = var104
		local any_ViewportPointToRay_result1_2 = Camera_2:ViewportPointToRay(var114.X, var114.Y)
		local any_FindPartOnRayWithIgnoreList_result1, _ = Workspace_upvr:FindPartOnRayWithIgnoreList(Ray.new(any_ViewportPointToRay_result1_2.Origin, any_ViewportPointToRay_result1_2.Direction * (var115 - 0.25)), arg1.ObstacleBlacklist)
		if any_FindPartOnRayWithIgnoreList_result1 then
			arg3.ImageTransparency = 1
			return
		end
		if arg3.ImageTransparency == 1 then
			arg3.ImageTransparency = 0.33
		end
	end
end
function module_upvr_2.UpdateCircle(arg1, arg2, arg3) -- Line 441
	-- KONSTANTWARNING: Variable analysis failed. Output will have some incorrect variable assignments
	local Camera_3 = arg1.Camera
	local var131
	local function INLINED_3() -- Internal function, doesn't exist in bytecode
		var131 = arg1.Adornee:GetModelCFrame()
		return var131
	end
	if not arg1.IsAdorneeModel or not INLINED_3() then
		var131 = arg1.Adornee.CFrame
	end
	if not arg1.IsAdorneeModel or not arg1.Adornee:GetModelSize() then
	end
	local Vector3_FromAxis_result1 = Vector3.FromAxis(arg2)
	local Vector3_FromNormalId_result1 = Vector3.FromNormalId(arg1.AxisToSide[arg2])
	local any_WorldToViewportPoint_result1, _ = Camera_3:WorldToViewportPoint(var131.p)
	local Z_3 = any_WorldToViewportPoint_result1.Z
	any_WorldToViewportPoint_result1 = Vector2.new(any_WorldToViewportPoint_result1.X, any_WorldToViewportPoint_result1.Y)
	local var137 = any_WorldToViewportPoint_result1
	if Z_3 < 0 then
		var137 = Camera_3.ViewportSize - var137
	end
	local var138 = 1
	if arg1.IsMouseAvailable then
		var138 = 1
	else
		var138 = 1.6
	end
	local var139 = arg1.Adornee.Size.magnitude / 2 + (2) * (math.max(var138, 2 * math.tan(math.rad(Camera_3.FieldOfView) / 2) * Z_3 / Camera_3.ViewportSize.X * 14) * var138)
	local var140 = (-math.pi*2) / #arg3
	for i_9, v_8 in ipairs(arg3) do
		local var144 = (CFrame.fromAxisAngle(Vector3_FromAxis_result1, var140 * (i_9 - 1))) * (Vector3_FromNormalId_result1 * var139)
		local var145 = (CFrame.fromAxisAngle(Vector3_FromAxis_result1, var140 * i_9)) * (Vector3_FromNormalId_result1 * var139)
		local any_Lerp_result1 = var144:Lerp(var145, 0.5)
		local any_WorldToViewportPoint_result1_2, _ = Camera_3:WorldToViewportPoint(var131 * any_Lerp_result1)
		local Z_2 = any_WorldToViewportPoint_result1_2.Z
		any_WorldToViewportPoint_result1_2 = Vector2.new(any_WorldToViewportPoint_result1_2.X, any_WorldToViewportPoint_result1_2.Y)
		local var150 = any_WorldToViewportPoint_result1_2
		if Z_2 < 0 then
			var150 = Camera_3.ViewportSize - var150
		end
		v_8.Radius = (1.5) * (2 * math.tan(math.rad(Camera_3.FieldOfView) / 2) * Z_2 / Camera_3.ViewportSize.X) / 2
		v_8.CFrame = CFrame.new(any_Lerp_result1, var145) * CFrame.new(0, 0, v_8.Radius / 2)
		v_8.Height = (var145 - var144).magnitude
	end
end
function module_upvr_2.Destroy(arg1) -- Line 496
	arg1.Running = nil
	arg1.Maid:Destroy()
end
return module_upvr_2